// gl_bridge.js — WebGL 2 implementation of the weir-opengl API
//
// Provides the same 11-function API as gl_helper.c but using WebGL 2 + Canvas.
// Imported by the WASM module as "env" functions.

export function createGLBridge(canvas) {
    let memory = null;
    let gl = null;
    let program = null;
    let posBuffer = null;
    let colorBuffer = null;
    let width = 0;
    let height = 0;

    // Batch renderer state
    let quadPositions = [];
    let quadColors = [];

    // Key state for edge detection
    const MAX_KEYS = 512;
    const keysCurrent = new Uint8Array(MAX_KEYS);
    const keysPrevious = new Uint8Array(MAX_KEYS);

    // GLFW key code → JS keyCode mapping (GLFW special keys are 256+)
    const glfwToJS = {
        256: 27,   // ESCAPE
        257: 13,   // ENTER
        258: 9,    // TAB
        259: 8,    // BACKSPACE
        260: 45,   // INSERT
        261: 46,   // DELETE
        262: 39,   // RIGHT
        263: 37,   // LEFT
        264: 40,   // DOWN
        265: 38,   // UP
        266: 33,   // PAGE_UP
        267: 34,   // PAGE_DOWN
        268: 36,   // HOME
        269: 35,   // END
    };
    function mapKey(glfwKey) {
        const k = Number(glfwKey);
        return glfwToJS[k] ?? k; // printable keys (32-96) are the same
    }

    // Embedded 8x8 bitmap font (CP437 printable ASCII 32-126)
    // Same data as gl_helper.c font8x8 array
    const font8x8 = [
        [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00], // 32 (space)
        [0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00], // 33 !
        [0x6C,0x6C,0x24,0x00,0x00,0x00,0x00,0x00], // 34 "
        [0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00], // 35 #
        [0x18,0x7E,0xC0,0x7C,0x06,0xFC,0x18,0x00], // 36 $
        [0x00,0xC6,0xCC,0x18,0x30,0x66,0xC6,0x00], // 37 %
        [0x38,0x6C,0x38,0x76,0xDC,0xCC,0x76,0x00], // 38 &
        [0x18,0x18,0x30,0x00,0x00,0x00,0x00,0x00], // 39 '
        [0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00], // 40 (
        [0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00], // 41 )
        [0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00], // 42 *
        [0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00], // 43 +
        [0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30], // 44 ,
        [0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00], // 45 -
        [0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00], // 46 .
        [0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00], // 47 /
        [0x7C,0xC6,0xCE,0xD6,0xE6,0xC6,0x7C,0x00], // 48 0
        [0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00], // 49 1
        [0x7C,0xC6,0x06,0x1C,0x30,0x66,0xFE,0x00], // 50 2
        [0x7C,0xC6,0x06,0x3C,0x06,0xC6,0x7C,0x00], // 51 3
        [0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x1E,0x00], // 52 4
        [0xFE,0xC0,0xFC,0x06,0x06,0xC6,0x7C,0x00], // 53 5
        [0x38,0x60,0xC0,0xFC,0xC6,0xC6,0x7C,0x00], // 54 6
        [0xFE,0xC6,0x0C,0x18,0x30,0x30,0x30,0x00], // 55 7
        [0x7C,0xC6,0xC6,0x7C,0xC6,0xC6,0x7C,0x00], // 56 8
        [0x7C,0xC6,0xC6,0x7E,0x06,0x0C,0x78,0x00], // 57 9
        [0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00], // 58 :
        [0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30], // 59 ;
        [0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00], // 60 <
        [0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00], // 61 =
        [0x60,0x30,0x18,0x0C,0x18,0x30,0x60,0x00], // 62 >
        [0x7C,0xC6,0x0C,0x18,0x18,0x00,0x18,0x00], // 63 ?
        [0x7C,0xC6,0xDE,0xDE,0xDE,0xC0,0x78,0x00], // 64 @
        [0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0x00], // 65 A
        [0xFC,0x66,0x66,0x7C,0x66,0x66,0xFC,0x00], // 66 B
        [0x3C,0x66,0xC0,0xC0,0xC0,0x66,0x3C,0x00], // 67 C
        [0xF8,0x6C,0x66,0x66,0x66,0x6C,0xF8,0x00], // 68 D
        [0xFE,0x62,0x68,0x78,0x68,0x62,0xFE,0x00], // 69 E
        [0xFE,0x62,0x68,0x78,0x68,0x60,0xF0,0x00], // 70 F
        [0x3C,0x66,0xC0,0xC0,0xCE,0x66,0x3E,0x00], // 71 G
        [0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x00], // 72 H
        [0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00], // 73 I
        [0x1E,0x0C,0x0C,0x0C,0xCC,0xCC,0x78,0x00], // 74 J
        [0xE6,0x66,0x6C,0x78,0x6C,0x66,0xE6,0x00], // 75 K
        [0xF0,0x60,0x60,0x60,0x62,0x66,0xFE,0x00], // 76 L
        [0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0x00], // 77 M
        [0xC6,0xE6,0xF6,0xDE,0xCE,0xC6,0xC6,0x00], // 78 N
        [0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00], // 79 O
        [0xFC,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00], // 80 P
        [0x7C,0xC6,0xC6,0xC6,0xD6,0xDE,0x7C,0x06], // 81 Q
        [0xFC,0x66,0x66,0x7C,0x6C,0x66,0xE6,0x00], // 82 R
        [0x7C,0xC6,0xE0,0x7C,0x0E,0xC6,0x7C,0x00], // 83 S
        [0x7E,0x5A,0x18,0x18,0x18,0x18,0x3C,0x00], // 84 T
        [0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00], // 85 U
        [0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x00], // 86 V
        [0xC6,0xC6,0xC6,0xD6,0xFE,0xEE,0xC6,0x00], // 87 W
        [0xC6,0xC6,0x6C,0x38,0x6C,0xC6,0xC6,0x00], // 88 X
        [0x66,0x66,0x66,0x3C,0x18,0x18,0x3C,0x00], // 89 Y
        [0xFE,0xC6,0x8C,0x18,0x32,0x66,0xFE,0x00], // 90 Z
        [0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00], // 91 [
        [0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00], // 92 backslash
        [0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00], // 93 ]
        [0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00], // 94 ^
        [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF], // 95 _
        [0x30,0x18,0x0C,0x00,0x00,0x00,0x00,0x00], // 96 `
        [0x00,0x00,0x78,0x0C,0x7C,0xCC,0x76,0x00], // 97 a
        [0xE0,0x60,0x7C,0x66,0x66,0x66,0xDC,0x00], // 98 b
        [0x00,0x00,0x7C,0xC6,0xC0,0xC6,0x7C,0x00], // 99 c
        [0x1C,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00], // 100 d
        [0x00,0x00,0x7C,0xC6,0xFE,0xC0,0x7C,0x00], // 101 e
        [0x38,0x6C,0x60,0xF0,0x60,0x60,0xF0,0x00], // 102 f
        [0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0xF8], // 103 g
        [0xE0,0x60,0x6C,0x76,0x66,0x66,0xE6,0x00], // 104 h
        [0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00], // 105 i
        [0x06,0x00,0x0E,0x06,0x06,0x66,0x66,0x3C], // 106 j
        [0xE0,0x60,0x66,0x6C,0x78,0x6C,0xE6,0x00], // 107 k
        [0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00], // 108 l
        [0x00,0x00,0xCC,0xFE,0xFE,0xD6,0xD6,0x00], // 109 m
        [0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x00], // 110 n
        [0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0x00], // 111 o
        [0x00,0x00,0xDC,0x66,0x66,0x7C,0x60,0xF0], // 112 p
        [0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0x1E], // 113 q
        [0x00,0x00,0xDC,0x76,0x60,0x60,0xF0,0x00], // 114 r
        [0x00,0x00,0x7C,0xC0,0x7C,0x06,0xFC,0x00], // 115 s
        [0x30,0x30,0xFC,0x30,0x30,0x36,0x1C,0x00], // 116 t
        [0x00,0x00,0xCC,0xCC,0xCC,0xCC,0x76,0x00], // 117 u
        [0x00,0x00,0xC6,0xC6,0xC6,0x6C,0x38,0x00], // 118 v
        [0x00,0x00,0xC6,0xD6,0xFE,0xFE,0x6C,0x00], // 119 w
        [0x00,0x00,0xC6,0x6C,0x38,0x6C,0xC6,0x00], // 120 x
        [0x00,0x00,0xC6,0xC6,0xC6,0x7E,0x06,0xFC], // 121 y
        [0x00,0x00,0xFE,0x8C,0x18,0x32,0xFE,0x00], // 122 z
        [0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00], // 123 {
        [0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00], // 124 |
        [0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00], // 125 }
        [0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00], // 126 ~
    ];

    function readString(ptr) {
        const mem = new Uint8Array(memory.buffer);
        let end = ptr;
        while (mem[end] !== 0) end++;
        return new TextDecoder().decode(mem.subarray(ptr, end));
    }

    function unpackColor(color) {
        // color is a BigInt (i64) — convert to Number
        const c = Number(color & BigInt(0xFFFFFF));
        const r = ((c >> 16) & 0xFF) / 255;
        const g = ((c >> 8) & 0xFF) / 255;
        const b = (c & 0xFF) / 255;
        return [r, g, b];
    }

    function initWebGL(w, h) {
        width = w;
        height = h;
        canvas.width = w;
        canvas.height = h;

        gl = canvas.getContext('webgl2');
        if (!gl) {
            console.error('WebGL 2 not available');
            return false;
        }

        // Vertex shader: receives position + color per vertex
        const vsSource = `#version 300 es
            in vec2 a_position;
            in vec3 a_color;
            out vec3 v_color;
            uniform vec2 u_resolution;
            void main() {
                // Convert pixel coords to clip space (-1 to 1)
                vec2 clip = (a_position / u_resolution) * 2.0 - 1.0;
                clip.y = -clip.y; // flip Y for top-left origin
                gl_Position = vec4(clip, 0.0, 1.0);
                v_color = a_color;
            }
        `;

        const fsSource = `#version 300 es
            precision mediump float;
            in vec3 v_color;
            out vec4 fragColor;
            void main() {
                fragColor = vec4(v_color, 1.0);
            }
        `;

        const vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, vsSource);
        gl.compileShader(vs);
        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
            console.error('VS:', gl.getShaderInfoLog(vs));
        }

        const fs = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fs, fsSource);
        gl.compileShader(fs);
        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
            console.error('FS:', gl.getShaderInfoLog(fs));
        }

        program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Link:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Set resolution uniform
        const resLoc = gl.getUniformLocation(program, 'u_resolution');
        gl.uniform2f(resLoc, width, height);

        // Create buffers
        posBuffer = gl.createBuffer();
        colorBuffer = gl.createBuffer();

        gl.clearColor(0.1, 0.1, 0.12, 1.0);
        gl.disable(gl.DEPTH_TEST);

        return true;
    }

    function flushQuads() {
        if (quadPositions.length === 0) return;

        const posArr = new Float32Array(quadPositions);
        const colArr = new Float32Array(quadColors);

        const posLoc = gl.getAttribLocation(program, 'a_position');
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, posArr, gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

        const colLoc = gl.getAttribLocation(program, 'a_color');
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, colArr, gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(colLoc);
        gl.vertexAttribPointer(colLoc, 3, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLES, 0, quadPositions.length / 2);

        quadPositions = [];
        quadColors = [];
    }

    function pushQuad(x, y, w, h, r, g, b) {
        // Two triangles per quad
        // Triangle 1: top-left, top-right, bottom-left
        quadPositions.push(x, y, x + w, y, x, y + h);
        quadColors.push(r, g, b, r, g, b, r, g, b);
        // Triangle 2: top-right, bottom-right, bottom-left
        quadPositions.push(x + w, y, x + w, y + h, x, y + h);
        quadColors.push(r, g, b, r, g, b, r, g, b);
    }

    // Set up keyboard listeners
    document.addEventListener('keydown', (e) => {
        const code = e.keyCode;
        if (code >= 0 && code < MAX_KEYS) {
            keysCurrent[code] = 1;
        }
        // Prevent default for arrow keys, space, etc.
        if ([32, 37, 38, 39, 40].includes(code)) {
            e.preventDefault();
        }
    });

    document.addEventListener('keyup', (e) => {
        const code = e.keyCode;
        if (code >= 0 && code < MAX_KEYS) {
            keysCurrent[code] = 0;
        }
    });

    const env = {
        gl_init(w, h, title) {
            const titleStr = readString(Number(title));
            document.title = titleStr;
            const ok = initWebGL(Number(w), Number(h));
            return ok ? BigInt(1) : BigInt(0);
        },

        gl_should_close() {
            // Browser never "closes" — JS drives the loop via requestAnimationFrame
            return BigInt(0);
        },

        gl_begin_frame() {
            gl.clear(gl.COLOR_BUFFER_BIT);
        },

        gl_end_frame() {
            // Flush any batched quads
            flushQuads();
            // Copy current -> previous AFTER input has been checked this frame
            keysPrevious.set(keysCurrent);
        },

        gl_draw_rect(x, y, w, h, color) {
            const [r, g, b] = unpackColor(color);
            pushQuad(Number(x), Number(y), Number(w), Number(h), r, g, b);
        },

        gl_draw_text(x, y, text, color) {
            const str = readString(Number(text));
            const [r, g, b] = unpackColor(color);
            let cx = Number(x);
            let cy = Number(y);

            for (let i = 0; i < str.length; i++) {
                let ch = str.charCodeAt(i);
                if (ch === 10) { // newline
                    cx = Number(x);
                    cy += 10;
                    continue;
                }
                if (ch < 32 || ch > 126) ch = 63; // '?'
                const glyph = font8x8[ch - 32];

                for (let row = 0; row < 8; row++) {
                    const bits = glyph[row];
                    for (let col = 0; col < 8; col++) {
                        if (bits & (0x80 >> col)) {
                            pushQuad(cx + col, cy + row, 1, 1, r, g, b);
                        }
                    }
                }
                cx += 8;
            }
        },

        gl_get_key(key) {
            const k = mapKey(key);
            if (k < 0 || k >= MAX_KEYS) return BigInt(0);
            return keysCurrent[k] ? BigInt(1) : BigInt(0);
        },

        gl_get_key_pressed(key) {
            const k = mapKey(key);
            if (k < 0 || k >= MAX_KEYS) return BigInt(0);
            return (keysCurrent[k] && !keysPrevious[k]) ? BigInt(1) : BigInt(0);
        },

        gl_time_ms() {
            return BigInt(Math.floor(performance.now()));
        },

        gl_screenshot(_path) {
            // No-op in browser (could use canvas.toBlob)
            return BigInt(0);
        },

        gl_cleanup() {
            // No-op in browser
        },
    };

    return {
        env,
        setMemory(mem) { memory = mem; },
    };
}
