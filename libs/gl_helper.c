// gl_helper.c — Simple GLFW + OpenGL 2.1 wrapper for Weir CFFI
//
// All functions use int64_t parameters to match Weir's calling convention.
// Strings are int64_t cast to const char*. Colors are packed 0xRRGGBB.

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <GLFW/glfw3.h>

// ── State ────────────────────────────────────────────────────────

static GLFWwindow *g_window = NULL;
static int g_width = 0;
static int g_height = 0;

// Key state for edge detection
#define MAX_KEYS 512
static int g_keys_current[MAX_KEYS];
static int g_keys_previous[MAX_KEYS];

// ── Embedded 8x8 bitmap font (CP437 printable ASCII 32-126) ─────

static const uint8_t font8x8[95][8] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // 32 (space)
    {0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00}, // 33 !
    {0x6C,0x6C,0x24,0x00,0x00,0x00,0x00,0x00}, // 34 "
    {0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00}, // 35 #
    {0x18,0x7E,0xC0,0x7C,0x06,0xFC,0x18,0x00}, // 36 $
    {0x00,0xC6,0xCC,0x18,0x30,0x66,0xC6,0x00}, // 37 %
    {0x38,0x6C,0x38,0x76,0xDC,0xCC,0x76,0x00}, // 38 &
    {0x18,0x18,0x30,0x00,0x00,0x00,0x00,0x00}, // 39 '
    {0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00}, // 40 (
    {0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00}, // 41 )
    {0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00}, // 42 *
    {0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00}, // 43 +
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30}, // 44 ,
    {0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00}, // 45 -
    {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00}, // 46 .
    {0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00}, // 47 /
    {0x7C,0xC6,0xCE,0xD6,0xE6,0xC6,0x7C,0x00}, // 48 0
    {0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00}, // 49 1
    {0x7C,0xC6,0x06,0x1C,0x30,0x66,0xFE,0x00}, // 50 2
    {0x7C,0xC6,0x06,0x3C,0x06,0xC6,0x7C,0x00}, // 51 3
    {0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x1E,0x00}, // 52 4
    {0xFE,0xC0,0xFC,0x06,0x06,0xC6,0x7C,0x00}, // 53 5
    {0x38,0x60,0xC0,0xFC,0xC6,0xC6,0x7C,0x00}, // 54 6
    {0xFE,0xC6,0x0C,0x18,0x30,0x30,0x30,0x00}, // 55 7
    {0x7C,0xC6,0xC6,0x7C,0xC6,0xC6,0x7C,0x00}, // 56 8
    {0x7C,0xC6,0xC6,0x7E,0x06,0x0C,0x78,0x00}, // 57 9
    {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00}, // 58 :
    {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30}, // 59 ;
    {0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00}, // 60 <
    {0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00}, // 61 =
    {0x60,0x30,0x18,0x0C,0x18,0x30,0x60,0x00}, // 62 >
    {0x7C,0xC6,0x0C,0x18,0x18,0x00,0x18,0x00}, // 63 ?
    {0x7C,0xC6,0xDE,0xDE,0xDE,0xC0,0x78,0x00}, // 64 @
    {0x38,0x6C,0xC6,0xC6,0xFE,0xC6,0xC6,0x00}, // 65 A
    {0xFC,0x66,0x66,0x7C,0x66,0x66,0xFC,0x00}, // 66 B
    {0x3C,0x66,0xC0,0xC0,0xC0,0x66,0x3C,0x00}, // 67 C
    {0xF8,0x6C,0x66,0x66,0x66,0x6C,0xF8,0x00}, // 68 D
    {0xFE,0x62,0x68,0x78,0x68,0x62,0xFE,0x00}, // 69 E
    {0xFE,0x62,0x68,0x78,0x68,0x60,0xF0,0x00}, // 70 F
    {0x3C,0x66,0xC0,0xC0,0xCE,0x66,0x3E,0x00}, // 71 G
    {0xC6,0xC6,0xC6,0xFE,0xC6,0xC6,0xC6,0x00}, // 72 H
    {0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // 73 I
    {0x1E,0x0C,0x0C,0x0C,0xCC,0xCC,0x78,0x00}, // 74 J
    {0xE6,0x66,0x6C,0x78,0x6C,0x66,0xE6,0x00}, // 75 K
    {0xF0,0x60,0x60,0x60,0x62,0x66,0xFE,0x00}, // 76 L
    {0xC6,0xEE,0xFE,0xFE,0xD6,0xC6,0xC6,0x00}, // 77 M
    {0xC6,0xE6,0xF6,0xDE,0xCE,0xC6,0xC6,0x00}, // 78 N
    {0x7C,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00}, // 79 O
    {0xFC,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00}, // 80 P
    {0x7C,0xC6,0xC6,0xC6,0xD6,0xDE,0x7C,0x06}, // 81 Q
    {0xFC,0x66,0x66,0x7C,0x6C,0x66,0xE6,0x00}, // 82 R
    {0x7C,0xC6,0xE0,0x7C,0x0E,0xC6,0x7C,0x00}, // 83 S
    {0x7E,0x5A,0x18,0x18,0x18,0x18,0x3C,0x00}, // 84 T
    {0xC6,0xC6,0xC6,0xC6,0xC6,0xC6,0x7C,0x00}, // 85 U
    {0xC6,0xC6,0xC6,0xC6,0xC6,0x6C,0x38,0x00}, // 86 V
    {0xC6,0xC6,0xC6,0xD6,0xFE,0xEE,0xC6,0x00}, // 87 W
    {0xC6,0xC6,0x6C,0x38,0x6C,0xC6,0xC6,0x00}, // 88 X
    {0x66,0x66,0x66,0x3C,0x18,0x18,0x3C,0x00}, // 89 Y
    {0xFE,0xC6,0x8C,0x18,0x32,0x66,0xFE,0x00}, // 90 Z
    {0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00}, // 91 [
    {0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00}, // 92 backslash
    {0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00}, // 93 ]
    {0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00}, // 94 ^
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF}, // 95 _
    {0x30,0x18,0x0C,0x00,0x00,0x00,0x00,0x00}, // 96 `
    {0x00,0x00,0x78,0x0C,0x7C,0xCC,0x76,0x00}, // 97 a
    {0xE0,0x60,0x7C,0x66,0x66,0x66,0xDC,0x00}, // 98 b
    {0x00,0x00,0x7C,0xC6,0xC0,0xC6,0x7C,0x00}, // 99 c
    {0x1C,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00}, // 100 d
    {0x00,0x00,0x7C,0xC6,0xFE,0xC0,0x7C,0x00}, // 101 e
    {0x38,0x6C,0x60,0xF0,0x60,0x60,0xF0,0x00}, // 102 f
    {0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0xF8}, // 103 g
    {0xE0,0x60,0x6C,0x76,0x66,0x66,0xE6,0x00}, // 104 h
    {0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00}, // 105 i
    {0x06,0x00,0x0E,0x06,0x06,0x66,0x66,0x3C}, // 106 j
    {0xE0,0x60,0x66,0x6C,0x78,0x6C,0xE6,0x00}, // 107 k
    {0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // 108 l
    {0x00,0x00,0xCC,0xFE,0xFE,0xD6,0xD6,0x00}, // 109 m
    {0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x00}, // 110 n
    {0x00,0x00,0x7C,0xC6,0xC6,0xC6,0x7C,0x00}, // 111 o
    {0x00,0x00,0xDC,0x66,0x66,0x7C,0x60,0xF0}, // 112 p
    {0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0x1E}, // 113 q
    {0x00,0x00,0xDC,0x76,0x60,0x60,0xF0,0x00}, // 114 r
    {0x00,0x00,0x7C,0xC0,0x7C,0x06,0xFC,0x00}, // 115 s
    {0x30,0x30,0xFC,0x30,0x30,0x36,0x1C,0x00}, // 116 t
    {0x00,0x00,0xCC,0xCC,0xCC,0xCC,0x76,0x00}, // 117 u
    {0x00,0x00,0xC6,0xC6,0xC6,0x6C,0x38,0x00}, // 118 v
    {0x00,0x00,0xC6,0xD6,0xFE,0xFE,0x6C,0x00}, // 119 w
    {0x00,0x00,0xC6,0x6C,0x38,0x6C,0xC6,0x00}, // 120 x
    {0x00,0x00,0xC6,0xC6,0xC6,0x7E,0x06,0xFC}, // 121 y
    {0x00,0x00,0xFE,0x8C,0x18,0x32,0xFE,0x00}, // 122 z
    {0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00}, // 123 {
    {0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00}, // 124 |
    {0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00}, // 125 }
    {0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00}, // 126 ~
};

// ── Helpers ──────────────────────────────────────────────────────

static void unpack_color(int64_t color, float *r, float *g, float *b) {
    *r = (float)((color >> 16) & 0xFF) / 255.0f;
    *g = (float)((color >> 8)  & 0xFF) / 255.0f;
    *b = (float)((color)       & 0xFF) / 255.0f;
}

// ── Public API ───────────────────────────────────────────────────

int64_t gl_init(int64_t w, int64_t h, int64_t title) {
    if (!glfwInit()) {
        fprintf(stderr, "gl_init: glfwInit failed\n");
        return 0;
    }

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);
    glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);

    g_width = (int)w;
    g_height = (int)h;

    g_window = glfwCreateWindow(g_width, g_height, (const char *)(intptr_t)title, NULL, NULL);
    if (!g_window) {
        fprintf(stderr, "gl_init: glfwCreateWindow failed\n");
        glfwTerminate();
        return 0;
    }

    glfwMakeContextCurrent(g_window);
    glfwSwapInterval(1); // vsync

    // Set up 2D orthographic projection (top-left origin)
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0.0, (double)g_width, (double)g_height, 0.0, -1.0, 1.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glDisable(GL_DEPTH_TEST);
    glClearColor(0.1f, 0.1f, 0.12f, 1.0f);

    memset(g_keys_current, 0, sizeof(g_keys_current));
    memset(g_keys_previous, 0, sizeof(g_keys_previous));

    return 1;
}

int64_t gl_should_close(void) {
    return glfwWindowShouldClose(g_window) ? 1 : 0;
}

void gl_begin_frame(void) {
    glClear(GL_COLOR_BUFFER_BIT);
    // Copy current → previous, then poll for new state
    memcpy(g_keys_previous, g_keys_current, sizeof(g_keys_current));
    glfwPollEvents();
    // Read current key state
    for (int i = 0; i < MAX_KEYS; i++) {
        g_keys_current[i] = (glfwGetKey(g_window, i) == GLFW_PRESS) ? 1 : 0;
    }
}

void gl_end_frame(void) {
    glfwSwapBuffers(g_window);
}

void gl_draw_rect(int64_t x, int64_t y, int64_t w, int64_t h, int64_t color) {
    float r, g, b;
    unpack_color(color, &r, &g, &b);
    glColor3f(r, g, b);
    glBegin(GL_QUADS);
    glVertex2f((float)x,       (float)y);
    glVertex2f((float)(x + w), (float)y);
    glVertex2f((float)(x + w), (float)(y + h));
    glVertex2f((float)x,       (float)(y + h));
    glEnd();
}

void gl_draw_text(int64_t x, int64_t y, int64_t text, int64_t color) {
    const char *str = (const char *)(intptr_t)text;
    float r, g, b;
    unpack_color(color, &r, &g, &b);

    int cx = (int)x;
    int cy = (int)y;

    for (const char *p = str; *p; p++) {
        unsigned char ch = (unsigned char)*p;
        if (ch == '\n') {
            cx = (int)x;
            cy += 10; // 8px + 2px spacing
            continue;
        }
        if (ch < 32 || ch > 126) ch = '?';
        const uint8_t *glyph = font8x8[ch - 32];

        for (int row = 0; row < 8; row++) {
            uint8_t bits = glyph[row];
            for (int col = 0; col < 8; col++) {
                if (bits & (0x80 >> col)) {
                    float px = (float)(cx + col);
                    float py = (float)(cy + row);
                    glColor3f(r, g, b);
                    glBegin(GL_QUADS);
                    glVertex2f(px,        py);
                    glVertex2f(px + 1.0f, py);
                    glVertex2f(px + 1.0f, py + 1.0f);
                    glVertex2f(px,        py + 1.0f);
                    glEnd();
                }
            }
        }
        cx += 8; // advance one character width
    }
}

int64_t gl_get_key(int64_t key) {
    if (key < 0 || key >= MAX_KEYS) return 0;
    return g_keys_current[key] ? 1 : 0;
}

int64_t gl_get_key_pressed(int64_t key) {
    if (key < 0 || key >= MAX_KEYS) return 0;
    return (g_keys_current[key] && !g_keys_previous[key]) ? 1 : 0;
}

int64_t gl_time_ms(void) {
    return (int64_t)(glfwGetTime() * 1000.0);
}

int64_t gl_screenshot(int64_t path) {
    const char *filepath = (const char *)(intptr_t)path;
    int w = g_width;
    int h = g_height;

    // Read pixels (bottom-up from OpenGL)
    int row_bytes = w * 3;
    int padded_row = (row_bytes + 3) & ~3;
    uint8_t *pixels = (uint8_t *)malloc(h * row_bytes);
    if (!pixels) return 0;
    glReadPixels(0, 0, w, h, GL_RGB, GL_UNSIGNED_BYTE, pixels);

    // Write BMP
    FILE *f = fopen(filepath, "wb");
    if (!f) { free(pixels); return 0; }

    int file_size = 54 + padded_row * h;
    uint8_t header[54];
    memset(header, 0, 54);
    // BMP header
    header[0] = 'B'; header[1] = 'M';
    header[2]  = (uint8_t)(file_size);
    header[3]  = (uint8_t)(file_size >> 8);
    header[4]  = (uint8_t)(file_size >> 16);
    header[5]  = (uint8_t)(file_size >> 24);
    header[10] = 54; // pixel data offset
    // DIB header
    header[14] = 40; // DIB header size
    header[18] = (uint8_t)(w);       header[19] = (uint8_t)(w >> 8);
    header[20] = (uint8_t)(w >> 16); header[21] = (uint8_t)(w >> 24);
    header[22] = (uint8_t)(h);       header[23] = (uint8_t)(h >> 8);
    header[24] = (uint8_t)(h >> 16); header[25] = (uint8_t)(h >> 24);
    header[26] = 1;  // color planes
    header[28] = 24; // bits per pixel
    int img_size = padded_row * h;
    header[34] = (uint8_t)(img_size);
    header[35] = (uint8_t)(img_size >> 8);
    header[36] = (uint8_t)(img_size >> 16);
    header[37] = (uint8_t)(img_size >> 24);

    fwrite(header, 1, 54, f);

    // Write rows bottom-to-top (BMP is bottom-up, OpenGL already gives bottom-up)
    uint8_t pad[3] = {0, 0, 0};
    int pad_bytes = padded_row - row_bytes;
    for (int row = 0; row < h; row++) {
        uint8_t *src = pixels + row * row_bytes;
        // BMP stores BGR, we have RGB — swap
        for (int px = 0; px < w; px++) {
            uint8_t tmp = src[px * 3];
            src[px * 3] = src[px * 3 + 2];
            src[px * 3 + 2] = tmp;
        }
        fwrite(src, 1, row_bytes, f);
        if (pad_bytes > 0) fwrite(pad, 1, pad_bytes, f);
    }

    fclose(f);
    free(pixels);
    return 1;
}

void gl_cleanup(void) {
    if (g_window) {
        glfwDestroyWindow(g_window);
        g_window = NULL;
    }
    glfwTerminate();
}
